{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-30T01:04:02.032184+00:00",
  "repo": "cfrg/draft-irtf-cfrg-det-sigs-with-noise",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOIymWWc6ApNAK",
      "title": "For discussion section from draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/1",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Ordering of the parameters in \"dom2(F, C) || Z || prefix || 000... || PH(M)\" in Ed25519 and similar in Ed448 and ECDSA. There has also been sugestion to use a larger Z and to use several paddings 000....\r\n\r\n- Ilari Liusvaara pointed out attacks using the context that needs to be considered. Some statements \"first block is composed only of the hashed private key and the random value\" in the document are not true for Ed25519ctx and Ed448ctx.\r\n\r\n- Jim Schaad: Is there any advantage to stealing one of the zeros from the end padding and using it to pad between 'Z' and 'x' in the construction? I would assume that it should use the '0'/'1' construction between steps d and f.\r\n\r\n- Jim Schaad: Is there any advantage to padding with 0x01 in step f rather than 0x00?\r\n\r\n- Rene Stuik: MUST instead of RECOMMENDED.",
      "createdAt": "2024-02-28T07:21:43Z",
      "updatedAt": "2024-03-11T12:51:47Z",
      "closedAt": "2024-03-11T12:51:47Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "-use several paddings 000.... \r\n-pad between 'Z' and 'x'\r\n-statements are not true\r\n\r\nAre addressed in main. Closing this issue. If something needs further discussion we open a new more focused issue.",
          "createdAt": "2024-02-28T12:39:53Z",
          "updatedAt": "2024-02-28T12:39:53Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">Is there any advantage to padding with 0x01 in step f rather than 0x00?\r\n\r\nthis would not be compatible with HMAC_DRBG",
          "createdAt": "2024-03-11T12:51:20Z",
          "updatedAt": "2024-03-11T12:51:20Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOIymWWc6Ap0QG",
      "title": "Comments from Danny Niu - RNG use in ECDSA",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/2",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to let the interested parties know that, I've written a experimental C implementation of the draft. If anyone's interested in benchmarking or any kind of testing, I'd love to assist. I've also raised a few implementation-related issue at [crypto.stackexchange.com/a/106599/36960](http://crypto.stackexchange.com/a/106599/36960) and I'll summarize here:\r\n\r\n1. The draft treats ECDSA RNG as a white box and penetrates the PRNG boundary to seed it, which is something NIST specifies not to do. This isn't too big an issue, as there are ways to maintain functionality opacity.\r\n\r\n2. The draft underspecifies how to use KMAC when the hash function is SHAKE. The way I prefer is to persuade NIST to specify and approve a permutation-based PRNG and use that instead. However in the interim time, we could add details on how KMAC should be used with HMAC-DRBG, but again, it'll penetrate the PRNG boundary. What's more, KMAC had not been approved for use with HMAC-DRBG yet.",
      "createdAt": "2024-02-28T08:59:13Z",
      "updatedAt": "2024-04-24T15:14:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "Answering the email\r\n====\r\n\r\n> 1. I am correct in my understanding that this is concerning deterministic ECDSA (RFC 6979) and not just the hedged construction in draft-irtf-cfrg-det-sigs-with-noise?\r\n\r\nActually I directed my 1st comment directly at the new ECDSA hedged RNG construction. \r\n\r\nI'll have to **object** to the construction in the new https://www.ietf.org/archive/id/draft-irtf-cfrg-det-sigs-with-noise-02.html - It uses 2 different `Z` (`Zd` and `Zf`) which completely breaks PRNG boundary. I'll assume with best of my faith that this is an oversight caused by not being able to realize the rationales that I'll provide below.\r\n\r\nIf you look at [NIST.SP.800-90Ar1 Page 44 section 10.1.2.2](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf#page=53), there's only 1 single *provided_data* in the `HMAC_DRBG Update` process, and RFC-6979 was drafted in such way that PRNG behavior can be preserved. See [section 3.3 of RFC-6979](https://www.rfc-editor.org/rfc/rfc6979#section-3.3). So by changing the value(s) of `Z`, you're really changing an established CSPRNG algorithm!\r\n\r\nMy interpretation on this is that the \"deterministic\" ECDSA should be implementable by combining an existing signing implementation with an existing HMAC-DRBG implementation. If the new hedged ECDSA use 2 different `Z`s, then it will be impossible to combine them in such way.\r\n\r\n> 2. I don\u2019t see excactly what is missing for KMAC. Maybe you can describe in more detail in the GitHub issue?\r\n\r\nActually, there isn't much missing for KMAC, except we need to specify whether to *invoke* KMAC as a XOF (with L=0) or a fixed-length PRF (with L being 32, 48, <s>64</s> 66 (P-521)). \r\n\r\nThe other thing is just I hoped NIST can specify a DRBG based on Keccak-1600 so that something more efficient than KMAC can be adopted in the future.\r\n\r\nMore on PRNG boundary\r\n====\r\n\r\nI was recently amazed by [this StackExchange post](https://softwareengineering.stackexchange.com/q/452229/290091) which talks about \"tell, don't ask\" paradigm, which I think is nice. I think it's best to:\r\n\r\n- **tell** the PRNG we want to seed you with nonce, privkey, an H(msg), \r\n- **rather than asking** \"what's your block-length\", than doing seed nonce, pad, seed privkey, pad, seed H(msg).\r\n\r\nThe HMAC calls in step d and f are part of PRNG operation, and they shouldn't be exposed, not to mention altered. Querying the block size of the hash function is the most I consider reasonable in this circumstance.\r\n\r\n----\r\n\r\nExisting experience\r\n====\r\n\r\nMy parallel effort on [ML-DSA](https://github.com/dannyniu/MySuiteA/blob/b48deb7f9acc953f47eb9a10065b85355a2d011b/src/3-pq-crystals/mldsa.c#L371) and [SLH-DSA](https://github.com/dannyniu/MySuiteA/blob/b48deb7f9acc953f47eb9a10065b85355a2d011b/src/3-sphincs/slhdsa.c#L98) also shows that it's easiest when hedged generation of nonce is part of algorithm, and especially easy when it can switch seemlessly between hedged and deterministic.\r\n\r\nMy EdDSA was able to be modified in-place. However, my existing implementation for ECDSA (as well as the similar SM2 DSS from China - my homeland):\r\n\r\n1. didn't reserve a space for an instance of HMAC-DRBG\r\n2. was intended to be combined with an *external* PRNG from day-one of its design\r\n\r\nTherefore I implemented an external [`Signer`](https://github.com/dannyniu/MySuiteA/blob/c8b5537f4435759cac4bb6551d9a26aa7ee16f51/src/3-ecc-common/ecc-dss-sign-hedged.c). ",
          "createdAt": "2024-03-04T11:27:37Z",
          "updatedAt": "2024-03-05T04:06:30Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Danny,\r\n\r\nYes, we missed that different random number is not compatible with HMAC_DRBG. The reason that we suggested different random numbers was that this improves security against second-order DPA attacks. We agree that compliance with HMAC_DRBG seems more important. I have made commits that change to a single random value Z and gives you acknowledgement.\r\n\r\nhttps://author-tools.ietf.org/api/iddiff?doc_1=draft-irtf-cfrg-det-sigs-with-noise&url_2=https://cfrg.github.io/draft-irtf-cfrg-det-sigs-with-noise/draft-irtf-cfrg-det-sigs-with-noise.txt\r\n\r\n> Actually, there isn't much missing for KMAC, except we need to specify whether to invoke KMAC as a XOF (with L=0) or a fixed-length PRF (with L being 32, 48, 64 66 (P-521)).\r\n\r\nReading the current text is seems to be specified on a RECOMMENDED level to use the same value L as in the hashing of the message. I.e. when ECDSA is used with SHAKE128(M, 256) and SHAKE256(M, 512) as in RFC 8692 and FIPS-186-5, it is RECOMMENDED to use KMAC128(K, M, 256, \"\") and KMAC128(K, M, 512, \"\"). Note that L is specified in bits.\r\n\r\n",
          "createdAt": "2024-03-10T11:57:18Z",
          "updatedAt": "2024-03-10T11:57:18Z"
        },
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "Thanks, appreciated.\r\n\r\nNote that for the P-521 instance, 521 bits are needed, otherwise [lattice attack](https://eprint.iacr.org/2019/023.pdf) will work.\r\n\r\n> to use KMAC128(K, M, 256, \"\") and KMAC128(K, M, 512, \"\"). \r\n\r\nYou mean KMAC256(K, M, 512, \"\") with the 2nd instance?",
          "createdAt": "2024-03-10T12:31:07Z",
          "updatedAt": "2024-03-11T02:56:44Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@dannyniu Do you by any way have test vectors? Taylor R Campbell are asking for test vectors in #4\r\n",
          "createdAt": "2024-03-11T10:22:47Z",
          "updatedAt": "2024-03-11T10:22:47Z"
        },
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "@emanjon I can generate some, but some details are needed:\r\n\r\n1. (for ECDSA & EdDSA) against which revision should I generate my test vectors,\r\n2. (for ECDSA) which curves and hash lengths should I include? I'd go for P-256 and P-384 because that 2 are the ones I've implemented and also marked as recommended in [one of the IANA registeries](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8); whereas with P-521, we need to agree on whether to invoke KMAC with 521-bit output, or 2 successive 512-bit output with truncation.\r\n3. (for ECDSA) we'd be needing SHA-2+HMAC test vectors I presume?\r\n4. (for ECDSA) when instantiating with FIPS-202, do I use SHAKE+KMAC or the regular SHA-3 instances with HMAC (or some other combination)?\r\n5. (misc) would anyone be interested in a set of [BLAKE2](https://datatracker.ietf.org/doc/html/rfc7693) test vectors? BLAKE2 have both hashing and PRF modes.",
          "createdAt": "2024-03-11T11:03:43Z",
          "updatedAt": "2024-03-15T00:56:01Z"
        },
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "@ethorm I checked out the new draft, and noticed a reference to \"section 3.3 of RFC-8391\". However, there's no section 3.3 in RFC-8391, there's only 1 2nd-level subsection in RFC-8391.",
          "createdAt": "2024-03-15T01:05:00Z",
          "updatedAt": "2024-03-15T01:05:00Z"
        },
        {
          "author": "ethorm",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you @dannyniu, fixed it to reference RFC 6979.",
          "createdAt": "2024-03-15T10:11:33Z",
          "updatedAt": "2024-03-15T10:11:33Z"
        },
        {
          "author": "ethorm",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @dannyniu, \r\n\r\n> Note that for the P-521 instance, 521 bits are needed, otherwise [lattice attack](https://eprint.iacr.org/2019/023.pdf) will work.\r\n\r\nI assume that you mean that step h.2 of https://datatracker.ietf.org/doc/html/rfc6979#section-3.2 will be iterated twice. John just made a commit recommending that KMAC outputs at least qlen bits (more exactly max(d, qlen)), where qlen is from RFC 6979.",
          "createdAt": "2024-03-16T09:18:00Z",
          "updatedAt": "2024-03-16T09:18:56Z"
        },
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "@ethorm It looks great. \r\n\r\nI was going to say \"exactly 521 bits may cause difficulty for octet-oriented HMAC-DRBG implementations instantiated with KMAC\", because L=521 is baked into domain separation informations. So I prefer the wording change to \"at least max(d, qlen) bits\"; or allow L=0 to make the output idempotent (which I find more preferable) just like when instantiating with HMAC-SHA-512.\r\n\r\nBut I think I'll manage by breaking curve abstraction layer a bit. I'll let others raise their concern. At worst, I'll omit test vectors for P-521. When the next revision is posted on IETF data tracker, I'll try find time write up codes to generate test vectors.",
          "createdAt": "2024-03-16T11:27:49Z",
          "updatedAt": "2024-03-16T12:51:45Z"
        },
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "I found some problem.\r\n\r\nThe current wording makes P-521+KMAC-256 unimplementable without making some breaking changes to existing codebase, both established ones such as LibreSSL, OpenSSL, NSS, etc. as well as my own MySuiteA. This is mostly with respect to octet-oriented assumptions in current implementations.\r\n\r\nVast majority of existing codes are octet-oriented, this means that requesting a fraction bytes' output is impossible since lengths are specified in units of bytes (and are integer types). Therefore when instantiating HMAC-DRBG with KMAC-256 to use with P-521, the biggest common denominator is not 521 bits, but rather 66 bytes.\r\n\r\nOne possible way to implement this in signing subroutine would be:\r\n\r\n1. to request 66 bytes,\r\n2. interpret the bytes and convert it to big-endian integer (using OS2IP).\r\n3. right-shift 7 bits to get a 521-bit random number - this emulates what `leftmost(bitstr)` does.\r\n\r\nOn the same note, I recommend the following change to accomondate KMAC-instantiated HMAC-DRBG: change step h in [generation of k](https://datatracker.ietf.org/doc/html/rfc6979#section-3.2) to:\r\n\r\n> h. Apply the following algorithms until a proper value is found for k:\r\n> \r\n> 1. if KMAC is used: \r\n>\r\n>    `T = KMAC-{128,256}(K, V, ceil(qlen/8)*8, \"\")\r\n>\r\n> 2. if HMAC is used, repeat the following steps until tlen >= qlen:\r\n>\r\n>    2.1. V = HMAC_K(V)\r\n>    2.2. T = T || V\r\n>\r\n> 3. Compute k = bits2int(leftmost(T, qlen))\r\n>\r\n>    If that value of k is within the [1,q-1], and is suitable for ...\r\n>    ... Otherwise compute:\r\n>\r\n>    K = KMAC_K(V || 0)\r\n>    V = KMAC_K(V)\r\n>\r\n>    and repeat this step h.\r\n\r\nI said before not to break PRNG boundary, but since we're instantiating HMAC-DRBG with the unapproved combination of KMAC, the efficiency gain worth making the change. (although it's more preferable NIST specify a Keccak permutation-based PRNG.)",
          "createdAt": "2024-03-18T01:26:07Z",
          "updatedAt": "2024-03-19T09:47:56Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Byte alignment seems like a good idea to align with libraries. Requesting 66 bytes seems like a good idea.",
          "createdAt": "2024-04-23T09:48:28Z",
          "updatedAt": "2024-04-23T09:48:28Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "bits2int is already defined to do a right shift in Section 2.3.2, there is no need for an explicit leftmost function.\r\n\r\n(The right shift is actually much more annoying to implement than masking the 7 most significant bits, but we already need to implement it for ECDSA's hash2int, so might as well reuse it.)",
          "createdAt": "2024-04-23T09:56:02Z",
          "updatedAt": "2024-04-23T09:56:02Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR that changes the recommended output lenght of KMAC to 8*ceil(qlen/8). As FiloScottile commented bit2ins is already doing a rightshift.",
          "createdAt": "2024-04-24T15:14:40Z",
          "updatedAt": "2024-04-24T15:14:40Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOIymWWc6AqNBX",
      "title": "Suggestion from Bernstein - Allow switching order of Z and \"prefix\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/3",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/cfrg/GRigAYvZ8-Z8qmxJ1jOiKR8eLyQ/\r\n\r\n> Compute SHA-512(dom2(F, C) || Z || prefix || 000... || PH(M)),\r\n\r\nAlso, two useful rules of thumb regarding input concatenations (for\r\nmotivating attacks see, e.g., Crypto 1995 Preneel--van Oorschot): 1.\r\nNever put a variable-length input anywhere but last. Previous positions\r\ncan have fixed-length _hashes_ of other variable-length inputs. 2. Put\r\nwhatever is least likely to be attacker-predictable first. Both Z and\r\n\"prefix\" are less likely to be attacker-predictable than C; scenarios\r\nwhere RNG failures are the top threat should put \"prefix\" first, while\r\nscenarios where side channels are the top threat (which seems to be the\r\nscenario under discussion) should put Z first.\r\n\r\n---D. J. Bernstein",
      "createdAt": "2024-02-28T09:51:26Z",
      "updatedAt": "2024-03-18T04:07:32Z",
      "closedAt": "2024-03-18T04:07:31Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "I think it would be reasonable for the draft to spell out each variant, but this would come at some editorial cost. I think I would tackle this by trying to understand where the advice comes from: \r\n\r\n> 2. Put whatever is least likely to be attacker-predictable first.\r\n\r\nThis sounds sensible in general, but why does it apply here?",
          "createdAt": "2024-03-18T00:55:58Z",
          "updatedAt": "2024-03-18T00:55:58Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the meeting, putting Z before random prefix was done to not have any collisions between variants. Unclear if this is needed but it is a design principle in RFC 8032 so we will try to follow that.\r\n\r\nSeems to be agreement in the CFRG session at IETF 119 to focus on side-channel attacks and only have one variant.",
          "createdAt": "2024-03-18T04:07:31Z",
          "updatedAt": "2024-03-18T04:07:31Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOIymWWc6Avdkp",
      "title": "API and test vectors including Z",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/4",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Where does one find test vectors for the deterministic functions\r\ndefined here with the extra randomization parameters Z?\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/jmfn1b880x7-7gZKb7_uwLvE3oU/",
      "createdAt": "2024-02-28T21:48:17Z",
      "updatedAt": "2024-03-11T13:19:44Z",
      "closedAt": "2024-03-11T13:19:44Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Bernstein wrote:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/GRigAYvZ8-Z8qmxJ1jOiKR8eLyQ/\r\n\r\n>     Compute SHA-512(dom2(F, C) || Z || prefix || 000... || PH(M)),\r\n\r\nWhat stops implementors from forgetting to include PH(M) in the hash\r\ninput? I'd recommend building this on top of a deterministic interface\r\nwhere Z is an explicit input, and making sure to test that interface.",
          "createdAt": "2024-03-11T13:14:46Z",
          "updatedAt": "2024-03-11T13:14:46Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOIymWWc6Avd5e",
      "title": "Suggestion from Taylor R Campbell - Don't use Z twice",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/5",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": ">    *  Added note that Z in step f is not reused from step d.\r\n\r\nMay I suggest using different letters for this, or numbered instances\r\nlike Z0 and Z1?  It's confusing to define a function F(m, Z, Z) as\r\nyou're doing here where the two Z's are actually different parameters.\r\n\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/jmfn1b880x7-7gZKb7_uwLvE3oU/",
      "createdAt": "2024-02-28T21:49:19Z",
      "updatedAt": "2024-03-05T11:15:31Z",
      "closedAt": "2024-02-29T09:26:47Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in main",
          "createdAt": "2024-02-29T09:26:47Z",
          "updatedAt": "2024-02-29T09:26:47Z"
        },
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "Using different `Z` for steps d and f breaks PRNG boundary - RFC-6979 is essentially ECDSA plus a user-seeded HMAC-DRBG, using different `Z`s changes **and breaks** the PRNG algorithm. See [Issue 2](https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/2)",
          "createdAt": "2024-03-05T11:14:50Z",
          "updatedAt": "2024-03-05T11:15:31Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOIymWWc6B3ZUu",
      "title": "FIPS 186 compliant mode where message-dependent pseudorandom values are used as \u2018additional input\u2019?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/6",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "People have suggested a FIPS 186 compliant mode where message-dependent pseudorandom values are used as \u2018additional input\u2019 in the random number generation for randomized ECDSA [FIPS 186]. Such a mode could compliment the current hedged construction based on Deterministic ECDSA [RFC 6979].\r\nhttps://blogs.cisco.com/security/fips-and-deterministic-ecdsa-achieving-robust-security-and-conformance",
      "createdAt": "2024-03-11T10:32:08Z",
      "updatedAt": "2024-04-21T11:35:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "I believe Hedged ECDSA as described in draft-irtf-cfrg-det-sigs-with-noise-03 is already FIPS 186-5 compliant.\r\n\r\nIt's using HMAC_DRBG consistently with SP 800-90Ar1, with Z as entropy (which has length sufficient to provide the requested DRBG security strength for the ECDSA key size, double that in fact), no nonce (as allowed by SP 800-90Ar1, Sections 8.6.7 and 9.1), and a `personalization_string` of `000... || int2octets(x) || 000... || bits2octets(h1)` (consistent with SP 800-90Ar1, Section 8.7.1, \"The personalization string may contain secret information\").\r\n\r\nAlternatively, one could argue that `int2octets(x) || 000...` is the nonce, and `Z || 000...` is the entropy (which is allowed to be longer than the actual bits of entropy it contains). Yet another argument could be that the first half of Z is the entropy (since e.g. a 256 bit ECDSA key requires a DRGB with minimum security strength of 128 per SP 800-57 Part 1), and the second half is the nonce. We have options (and as I type this I think I like that last one the most).\r\n\r\nIt then uses this cryptographically strong DRBG to generate the nonce according to FIPS 186-5, Appendix A.3.2, \"Per-Message Secret Number Generation of Private Keys by Rejection Sampling\". RFC 6979 checks 0 < x < q, while Appendix A.4.2 checks 0 <= x < q-1 and then returns x + 1 (which is way more annoying to implement), but note that Appendix A.3.2 says \"Convert returned_bits to the (non-negative) integer k using the procedure in Appendix A.4.2 *or an equivalent process*\" (emphasis mine).\r\n\r\nAre there concerns about the compliance of the current version? I actually landed here by first rederiving the exact same scheme (except for the `000...` padding) as a FIPS-compliant hedged ECDSA I will need to implement, and then remembering about this draft, and I was happy to find it similarly compliant.",
          "createdAt": "2024-04-21T00:06:46Z",
          "updatedAt": "2024-04-21T00:06:46Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "Ah, actually, more evidence from SP 800-90Ar1, Section 8.6.7 in support of just calling Z entropy+nonce.\r\n\r\n> For case 1 above, the random value could be acquired from the same source and at the same time as the entropy input. In this case, the seed could be considered to be constructed from an \u201cextra strong\u201d entropy input and the optional personalization string, where the entropy for the entropy input is equal to or greater than (3/2 security_strength) bits.\r\n\r\nThis is very reasonable, especially for ECDSA nonce generation, because this use case is susceptible to birthday bounds. This is explicitly called out.\r\n\r\n> The nonce provides greater assurance that the DRBG provides security_strength bits of security to the consuming application. If a DRBG were instantiated many times without a nonce, a compromise could become more likely. In some consuming applications, a single DRBG compromise could reveal long-term secrets (e.g., a compromise of the DSA per-message secret could reveal the signing key).\r\n\r\nGiven P-256, P-384, and P-521 require a security strength of 128, 192, and 256 respectively per SP 800-57 Part 1 Rev. 5, Section 5.6.1.1, the Z length of 256, 384, and 528 respectively is always greater than 3/2 security_strength.\r\n\r\nAlso, SHA-256 or better is sufficient for all those security strengths per SP 800-57 Part 1 Rev. 5, Section 5.6.1.2. From SP 800-90Ar1, Section 10.1:\r\n\r\n> The maximum security strength that can be supported by each DRBG based on a hash function is the security strength of the hash function for pre-image resistance; these security strengths are provided in [SP 800-107]. [SP 800-57] identifies hash functions that can be used to support a required security strength.",
          "createdAt": "2024-04-21T11:35:55Z",
          "updatedAt": "2024-04-21T11:35:55Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOIymWWc6B4LbK",
      "title": "Algorithm naming - Comment by Simon Josefsson",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/7",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/cfrg/EuHdNSQf_bsMWemjvbec-hTbWkw/\r\n\r\nI believe this document should not update/modify the core EdDSA/ECDSA\r\nalgorithms but instead it should specify new names for the alternative\r\nEdDSA/ECDSA variant it is attempting to introduce.\r\n\r\nIt would cause confusion to modify a tiny but security-critical piece of\r\na crypto algorithm, that is only applicable to certain environments, and\r\ncontinue to use the same name for the new algorithm that has different\r\nsecurity properties.\r\n\r\nI suggest using the name 'R* for the variants, e.g., 'REd25519ph',\r\n'REd25519ctx', 'REd25519 etc.\r\n\r\nThen any IoT specification that wants to use the REd25519 variant can do\r\nso clearly, and those specifications/implementations that do not want to\r\nuse it is not put at risk by using a library that implements 'Ed25519'\r\nthat happened to have adopted this modification.\r\n\r\n",
      "createdAt": "2024-03-11T12:15:50Z",
      "updatedAt": "2024-03-18T04:09:34Z",
      "closedAt": "2024-03-18T04:09:34Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "I think coming up with new names is likely to cause confusion. As an implementer, I would expect two algorithms with different names to be wire incompatible with one another. To the contrary, it sounds like the intent is to keep wire compatibility and just harden nonce generation. (A good goal, I think.)\r\n\r\nI think the ideal outcome for this draft would be adoption of the recommendation in cryptographic libraries without users of those libraries having to worry about API-breaking changes. If we do this right, then addressing the threat model is simply a matter of upgrading to the next minor version of the library :)",
          "createdAt": "2024-03-18T00:48:57Z",
          "updatedAt": "2024-03-18T00:48:57Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton I agree. Currently we have Randomized ECDSA and Deterministic ECDSA. The document definines Hedged ECDSA. The plan is to call it Hedged EdDSA. More specific names would be Hedged Ed25519ph, Hedged Ed25519ctx, and hedged Ed25519.\r\n",
          "createdAt": "2024-03-18T02:11:47Z",
          "updatedAt": "2024-03-18T02:11:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems to be agreement in the CFRG session at IETF 119 to go with \"Hedged EdDSA\" or \"Hedged Ed25519ph\", \"Hedged Ed25519ctx\", and \"Hedged Ed25519\" if more specification is needed",
          "createdAt": "2024-03-18T04:09:34Z",
          "updatedAt": "2024-03-18T04:09:34Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOIymWWc6B4Oxp",
      "title": "RFC 2119 language - RECOMMENDED or MUST",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/8",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Rene Stuik strongly suggests MUST instead of RECOMMENDED.\r\n\r\nCurrent draft states:\r\n\r\n```\r\nIn deployments where side-channel and fault injection attacks are a concern, the following step is RECOMMENDED instead of step (2) in Section 5.1.6 of {{RFC8032}}:\r\n\r\nFor Ed448ph and Ed448: In deployments where side-channel and fault injection attacks are a concern, the following step is RECOMMENDED instead of step (2) in Section 5.2.6 of {{RFC8032}}:\r\n\r\nFor Deterministic ECDSA: In existing ECDSA deployments where side-channel and fault injection attacks are a concern, the following steps are RECOMMENDED instead of steps (d) and (f) in Section 3.2 of {{RFC6979}}:\r\n```",
      "createdAt": "2024-03-11T12:22:56Z",
      "updatedAt": "2024-03-18T04:05:04Z",
      "closedAt": "2024-03-18T04:05:03Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "\"RECOMMENDED\" seems more appropriate to me, given that the draft doesn't break compatibility with existing signatures.",
          "createdAt": "2024-03-18T00:37:24Z",
          "updatedAt": "2024-03-18T00:37:24Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "RECOMMENDED was also suggested in the CFRG session at IETF 119. We will go for RECOMMENDED. Anyone thinking otherwise can open a new issue.",
          "createdAt": "2024-03-18T04:05:04Z",
          "updatedAt": "2024-03-18T04:05:04Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOIymWWc6B4RnU",
      "title": "Remove step f section completely - Suggested by Yolan Romailler ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/9",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/cfrg/CfDtdteov0gBVetkvi6VPU6y3VU/\r\n```\r\n\r\nI would however recommend mentioning section 3.6 of RFC6979 in sections 4\r\nand 5 of this proposal.\r\nI also don't see why it is necessary to modify the step (f) in Section 3.2\r\nof [RFC6979], since the randomization is already taking place in step (d)\r\nwhen additional random data is provided there. I would recommend only\r\nmodifying step (d) to conform with the existing proposal for variants in\r\nRFC6976 section 3.6 and for ease of implementation.\r\nFinally, I'm not convinced by the need to \"middle\"-pad the input to HMAC\r\nwith \"a sequence of zero bits 000... chosen so that the length of (V ||\r\n0x00 || Z || int2octets(x) || 000...) is equal to block size of the hash\r\nfunction\". I don't see any rationale to do so. Indeed, we could instead set\r\nK = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || Z), where Z is\r\nthe  random data of the same length as int2octets(x) and that would be\r\n\"nicer\" and avoid implementers to needlessly worry about the underlying\r\nblock size of their hash, plus it would be conforming to section 3.6 of the\r\nRFC6979.\r\n```\r\n",
      "createdAt": "2024-03-11T12:28:24Z",
      "updatedAt": "2024-03-11T12:50:13Z",
      "closedAt": "2024-03-11T12:50:13Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Removing f does not work as the current step f does not include 000.... and Z. The result would then not be compatible with HMAC_DRBG",
          "createdAt": "2024-03-11T12:50:13Z",
          "updatedAt": "2024-03-11T12:50:13Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOIymWWc6B4qkK",
      "title": "Deterministic interface",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/10",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/jmfn1b880x7-7gZKb7_uwLvE3oU/\r\n\r\nTaylor R Campbell wrote:\r\nWhere does one find test vectors for the deterministic functions\r\ndefined here with the extra randomization parameters Z?\r\n\r\nDaniel Bernstein wrote:\r\n",
      "createdAt": "2024-03-11T13:17:45Z",
      "updatedAt": "2024-04-23T10:16:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Bernstein wrote:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/GRigAYvZ8-Z8qmxJ1jOiKR8eLyQ/\r\n\r\n>     Compute SHA-512(dom2(F, C) || Z || prefix || 000... || PH(M)),\r\n\r\nWhat stops implementors from forgetting to include PH(M) in the hash\r\ninput? I'd recommend building this on top of a deterministic interface\r\nwhere Z is an explicit input, and making sure to test that interface.",
          "createdAt": "2024-03-11T13:18:10Z",
          "updatedAt": "2024-03-11T13:18:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume the suggestion here is that the interface is inside of the specification. I.e., the end user calls Sign(sk, M) and the description in the specification is\r\n\r\nSign(sk, M):\r\n1. Generate random Z\r\n2. Sign(sk, M, Z)\r\n",
          "createdAt": "2024-03-11T13:41:42Z",
          "updatedAt": "2024-03-11T13:41:42Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "I think this is a good idea.",
          "createdAt": "2024-03-18T02:40:11Z",
          "updatedAt": "2024-03-18T02:40:11Z"
        },
        {
          "author": "FiloSottile",
          "authorAssociation": "NONE",
          "body": "Big fan of derandomized interfaces, and NIST is planning to introduce them for the PQ algorithms (https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/Mf2kemwwreY/m/oF8HfaNxAQAJ) so I like the idea of a testable `Sign_internal(sk, M, Z)`, but only if it doesn't delay this draft further. I'd like to implement this and produce shared test vectors for it ASAP :)",
          "createdAt": "2024-04-21T00:17:27Z",
          "updatedAt": "2024-04-21T00:17:27Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems to be strong support for specifying a derandomized interface. We will add that. ",
          "createdAt": "2024-04-23T10:12:53Z",
          "updatedAt": "2024-04-23T10:12:53Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'd like to implement this and produce shared test vectors for it ASAP :)\r\nNoted, let's try to move this draft to publications asap. Early comments was mostly about naming and IPR, It is just recently we have gotten a lot of good technical comments, which are very welcome. ",
          "createdAt": "2024-04-23T10:16:11Z",
          "updatedAt": "2024-04-23T10:16:11Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOIymWWc6B4rhw",
      "title": "Test vectors including Z ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/11",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Taylor R Campbell wrote:\r\nWhere does one find test vectors for the deterministic functions\r\ndefined here with the extra randomization parameters Z?\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/cfrg/jmfn1b880x7-7gZKb7_uwLvE3oU/",
      "createdAt": "2024-03-11T13:19:35Z",
      "updatedAt": "2024-03-18T08:12:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "<s>[2023-hedged-dss.testvecs-local.d.zip](https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/files/14627035/2023-hedged-dss.testvecs-local.d.zip)</s>\r\n\r\nI've generated preliminary test vectors. Test vectors for some parameters and features (e.g. P-521, EdDSA pre-hash and context strings) hasn't been generated for now, although it should be easy. \r\n\r\nThe zip file also contain scripts and codes that generated the test vector. To use it, place the \"2023-hedged-dss.testvecs-local.d\" directory under the \"utils\" directory in the \"2023-hedged-dss\" branch of [MySuiteA](https://github.com/dannyniu/MySuiteA), and hack it all you want.\r\n\r\nI encourage 3rd-party implementations to cross check on the correctness of the test vectors, to find potential errors that may have crept in.\r\n\r\n----\r\n\r\n**2024-03-18 Update**\r\n\r\nThe test vectors for ECDSA instantiated with P-384/SHAKE-256 + KMAC-256 was in error due to an inconsistency between my implementation and the *-03 draft. I've noted this and raised some other concerns in https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/issues/2#issuecomment-2002716578\r\n\r\nI've revised the test vectors in this regard: [2023-hedged-dss.testvecs-local.d.zip](https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/files/14632671/2023-hedged-dss.testvecs-local.d.zip)\r\n",
          "createdAt": "2024-03-17T10:24:26Z",
          "updatedAt": "2024-03-18T08:12:29Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 12,
      "id": "PR_kwDOIymWWc5tnbkF",
      "title": "Optimize KMAC construction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-det-sigs-with-noise/pull/12",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Optimize KMAC construction\r\nSee #2",
      "createdAt": "2024-04-24T15:11:27Z",
      "updatedAt": "2024-05-02T06:49:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-det-sigs-with-noise",
      "baseRefName": "main",
      "baseRefOid": "9359dadf856c9fdbec1a43ad177435fc27f802d3",
      "headRepository": "cfrg/draft-irtf-cfrg-det-sigs-with-noise",
      "headRefName": "Optimize-KMAC-construction",
      "headRefOid": "9128a1240abc6e628d56ea17eeff7daa27ae9be4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dannyniu",
          "authorAssociation": "NONE",
          "body": "Hi there, \r\n\r\nDid you add a definition of the `ceil` unary operator / function?",
          "createdAt": "2024-05-02T06:49:21Z",
          "updatedAt": "2024-05-02T06:49:21Z"
        }
      ],
      "reviews": []
    }
  ]
}